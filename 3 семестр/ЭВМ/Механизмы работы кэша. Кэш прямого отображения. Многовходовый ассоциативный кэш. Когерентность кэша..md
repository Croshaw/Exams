[[ЭВМ|<==]]
# Механизмы работы кэша
К настоящему времени разработано несколько различных вариантов организации кэша. Рассмотрим наиболее известные из них. В общем случае кэш состоит из области хранения данных, в которой находятся копии некоторых полей оперативной памяти — собственно **кэш-памяти**, или **памяти данных**, и области, которая содержит управляющую информацию в виде набора признаков, описывающих находящиеся в кэше копии. Эту область кэша называют **памятью тегов**.
# Кэш прямого отображения
Исторически первым и наиболее простым является **кэш прямого отображения**. Память для хранения копий делится на элементы, которые принято называть **строками кэша**. Строки кэша могут быть различной длины. Довольно часто используется длина 32 байта, соответствующая стандартно передаваемой из оперативной памяти в процессор группе байтов (пакету). Роль строки кэша состоит в том, что данные из оперативной памяти дублируются в кэш сразу целой строкой, которая содержит запрошенное процессором поле памяти. Таким образом, в кэш попадает не только копия требуемого поля, но и копия группы байтов, расположенных рядом с ним.
Количество строк в кэше зависит от имеющегося в компьютере физического объёма кэша и от длины его строк. Так, например, кэш объемом 4 Кбайт может состоять из 128 тридцатидвухбайтных или из 256 шестнадцатибайтных строк. Встречаются и другие варианты. Каждой строке кэш-памяти однозначно соответствует элемент памяти тегов, который содержит значения рассматриваемых далее признаков этой строки.
Для получения простого и быстродействующего механизма поиска контроллер кэша рассматривает всю имеющуюся оперативную память как совокупность страниц, которые равны по обыму кэшу и также состоят из строк. Простота дублирования и поиска в кэше обеспечивается тем, что копия любой строки из любой страницы всегда занимает в кэше точно такое же положение, что и оригинал на соответствующей странице оперативной памяти. Это значит, что смещение копии строки относительно начала кэш-памяти всегда равно смещению оригинала строки относительно начала ее страницы в оперативной памяти. Таким образом, страница оперативной памяти как бы полностью отображается на память данных в кэше — отсюда и название «кэш прямого отображения».
Каждая страница оперативной памяти имеет номер, который принято называть **тегом**. Когда копия строки из какой-либо страницы попадает в кэш, ее тег занимает одноименное поле соответствующего элемента памяти тегов. Для определения положения запрошенного процессором байта контроллер кэша выделяет в его физическом адресе три участка. Находящиеся в этих участках коды считаются номером страницы оперативной памяти, номером строки на странице и номером байта в строке. Разрядность участков зависит от длины физического адреса, количества страниц и длины строк.
В случае, не совпадения структуры кэша и адреса имеет место **промах кэша**. Тогда процессор осуществит выборку из оперативной памяти. Кроме того, произойдет замена всей строки кэша с номером, а также соответствующего строке элемента памяти тегов. В таких случаях говорят, что произошло **вытеснение** строки из кэша.
Основным достоинством кэш-памяти прямого отображения является высокая скорость определения попадания или промаха. Кроме того, весьма просто решаются основные задачи управления кэшем, в частности, задача вытеснения строки, когда кэш уже заполнен.

![[Pasted image 20240108230052.png]]
Рисунок 1 — Кэш прямого отображения

# Многовходовый ассоциативный кэш
Кэш прямого отображения имеет и существенный недостаток. В него могут попасть только копии строк с разными номерами из одной и той же или из разных страниц оперативной памяти. Копии строк, которые имеют один и тот же номер, но расположены на разных страницах, не могут одновременно находиться в кэше, так как при любой попытке обратиться к строке на другой странице копия строки из первой страницы заменяется в кэше. Например, в кэше не могут одновременно находиться копии строки с номером $53_{16}$ из $18_{16}$-й и $20_{16}$-й страниц памяти, так как обращение к $20_{16}$-й странице вытеснит из кэша копию этой строки из $18_{16}$-й страницы. Такая замена требует дополнительных временных расходов, и при частых заменах весь выигрыш от наличия кэша может исчезнуть, а то и заменится снижением общей эффективности из-за необходимости вместо байта или слова считывать из оперативной памяти каждый раз целую строку.
Размещение в кэше двух и более копий «однономерных» строк из разных страниц оперативной памяти допускается в так называемом **ассоциативном кэше с множественным доступом**, или **многовходовом ассоциативном кэше**. Иногда такой вариант организации называют **наборно-ассоциативным кэшем**. Количество копий «однономерных» строк из разных страниц, которые могут быть помещены в кэш, может отражаться в названии кэша: n-входовый ассоциативный кэш, например двухвходовый кэш. Понятно, что n-входовый кэш допускает наличие в нем n копий «однономерных» строк. В настоящее время наиболее распространены четырех- и восьмивходовые ассоциативные кэши.

![[Pasted image 20240108230405.png]]
Рисунок 2 — Двухвходовой ассоциативный кэш

На рисунке 2 изображен двухвходовый ассоциативный кэш. По сути дела он представляет собой два экземпляра кэша прямого отображения, которые принято называть **банками кэша**. Каждый из банков ассоциативного кэша может содержать копию строки с одним и тем же номером, но из разных страниц памяти.
# Когерентность кэша
Выполнение операций считывания кодов при наличии кэша не вызывает особых проблем. Сложности начинаются при выполнении операций записи. Они вызваны наличием нескольких копий одного и того же кода в разных местах. С течением времени одна из копий кода может быть обновлена, заменена другим значением. Тогда возникает несовпадение находящихся в разных местах значений одной и той же величины. Задача поддержания одинаковых значений у кодов, находящихся в оперативной памяти и в кэше, называется проблемой когерентности кэша.
Когда исходный код находится в оперативной памяти, а его копия помещена в кэш, возможны два варианта нарушения когерентности. Во-первых, ко многовходовой оперативной памяти может обращаться не только процессор. Во-вторых, процессор может изменить значение в кэше, а код в оперативной памяти при этом оставить без изменения. Для регистрации описанных вариантов несоответствия в элементах памяти тегов предусмотрены флаг достоверности V (от validity — действительность) и флаг модификации М (от modify изменение). Флаг V принимает значение 1 при записи копии строки в кэш и сбрасывается в 0, если изменился соответствующий код в оперативной памяти. Флаг M, наоборот, принимает значение 0 при записи копии строки в кэш, а устанавливается в 1 при изменении значения в кэше.
В связи с введенным уточнением структуры элемента памяти тегов отметим, что для выборки кода из кэша оказывается недостаточно только совпадения тега и выделенного из физического адреса номера страницы. Дополнительно требуется, чтобы флаг достоверности V был равен 1, сигнализируя о том, что находящийся в кэше код действителен, то есть совпадает с оригиналом в оперативной памяти. Если это не так, процессору следует выбирать код из оперативной памяти.
Существует несколько способов поддержания когерентности кэша. В схеме **прямой записи** измененный процессором код заменяется в кэше и в оперативной памяти одновременно. Это надежный вариант, в котором несоответствие кодов не возникает. Вместе с тем его использование снижает быстродействие системы.
Более высокой эффективностью обладают схемы, которые выполняют запись в оперативную память с некоторой задержкой во времени относительно момента записи в кэш. При использовании **обратной записи**, которую называют также **буферизованной сквозной записью**, значение передается в память в первом же свободном такте работы процессора. А в схеме **отложенной записи** передача измененного кода в оперативную память выполняется только при окончательном заполнении кэша, то есть когда для помещения в кэш нового значения не оказывается свободной области.