[[ЭВМ|<==]]
# Многопрограммный режим работы компьютеров
Реальный режим процессоров Intel однопрограммный. В этом режиме все модели процессоров Intel являются логическими аналогами процессора i8086. Защищенный режим процессоров Intel — многопрограммный. В этом режиме реализован комплекс мер по защите программ от взаимного влияния и разрушения.
В отличие от реального режима, в защищенном режиме аппаратные и программные ресурсы компьютера должны быть распределены неким образом между всеми одновременно выполняющимися программами. Общие ресурсы компьютера могут использоваться такими программами одновременно либо по очереди.
Вместе с тем любой программе для ее полноценного и безошибочного выполнения требуются и принадлежащие только ей ресурсы. Наиболее важным из таких ресурсов являются индивидуальные участки оперативной памяти, доступ к которым может получить только программа-хозяйка и не могут другие программы. Так же монопольно должны закрепляться за программой специальные таблицы, в которых описываются выделенные ей участки памяти.
**Задачей** называется совокупность из выполняющейся программы и выделенных ей для выполнения аппаратных и программных ресурсов. Задача является основной единицей работы вычислительной системы в многопрограммном режиме. **Адресным пространством задачи** называется совокупность адресов оперативной памяти, по которым может обращаться выполняющаяся программа.
Для организации многопрограммной работы в защищенном режиме работы процессоров Intel предусмотрено несколько механизмов, обеспечивающих различные аспекты защиты. Это механизмы *сегментации, виртуальной памяти, привилегированного доступа, прерываний и переключения задач*. 
Механизм сегментации оперативной памяти в защищенном режиме обеспечивает программам такой доступ к сегментам, который делает невозможным взаимное разрушение программ во время их одновременного выполнения. Сегментация оперативной памяти в защищенном режиме существенно отличается от сегментации в реальном режиме.
В многопрограммном режиме каждой программе выделяется несколько сегментов памяти. Современным программам требуется довольно много памяти, поэтому количество сегментов, выделенных программе, может быть довольно большим. А если в оперативной памяти находится не одна программа, а несколько, то имеющегося в компьютере фактического объёма памяти может оказаться недостаточно. Следовательно, требуется механизм, который обеспечивает все выполняющиеся программы достаточным объемом оперативной памяти вне зависимости от реально имеющегося в компьютере ее объема. Таким механизмом является **виртуальная память**.
**Виртуальной памятью** называется механизм, обеспечивающий выполняющимся программам доступ к оперативной памяти, объем которой ограничен только адресным пространством компьютера и не зависит от имеющегося в нем фактического объема оперативной памяти.
В защищенном режиме сегментами оперативной памяти и виртуальной памятью управляют аппаратные средства компьютера, которые обеспечивают:
- компактность указания адреса в машинных командах программы;
- гибкость механизмов адресации, поддерживающих эффективную работу программы с данными любой сложной структуры;
- защиту адресных пространств задач;
- поддержку виртуальной памяти с возможным объемом до 4 Тбайт.
Механизм сегментации защищенного режима обеспечивает программам пользователей защиту от взаимного влияния, делая невозможным для любой такой программы доступ к «чужому» участку оперативной памяти. Вместе с тем операционная система для выполнения своих функций должна иметь доступ к любым участкам оперативной памяти, чтобы, например, при появлении ошибки в программе определить ее характер и местоположение. Таким образом, доступ к участку памяти должен зависеть от того, какая программа к нему обращается. Такое разграничение осуществляет механизм **привилегированного доступа**.
В многопрограммном режиме в оперативной памяти может находиться несколько программ на стадии выполнения. Но если центральный процессор в системе только один, то он выполняет такие программы поочередно, выделяя каждой из них некоторый временной интервал, который принято назвать **квантом времени**. В силу того что процессор работает очень быстро, в *режиме квантования времени* во многих случаях создается иллюзия того, что программы выполняются одновременно. Для реализации поочередного выполнения программ необходим некоторый механизм, регулирующий переход процессора от выполнения одной программы к выполнению другой. Такое регулирование осуществляется механизмом **переключения задач**.
# Сегментная модель памяти защищенного режима
Длина любого сегмента оперативной памяти в процессоре i8086 и в реальном режиме старших моделей процессоров всегда равна 64 Кбайт. Таким образом, сегмент обладает всего двумя атрибутами, адресом и типом. Различают три типа сегментов:
- сегмент кода;
- сегмент данных;
- сегмент стека.
В зависимости от типа сегмента его адрес (адрес начального байта сегмента) записывается в соответствующий сегментный регистр. Программа может обращаться к любому полю в любом сегменте как для чтения, так и для записи.
Такой механизм сегментации, удобный для однопрограммного режима, в многопрограммном режиме не обеспечивает защиту программ от взаимного уничтожения. В связи с этим свойства сегментов памяти в защищенном режиме были изменены. Любые сегменты памяти в защищенном режиме имеют следующие атрибуты:
- адрес начала сегмента;
- длина сегмента;
- тип сегмента, определяющий способ его использования в программе;
- уровень привилегий, определяющий права данного сегмента относительно других сегментов.
# Структура дескриптора сегмента
Значения или коды атрибутов сегмента оперативной памяти помещаются в специальное восьмибайтовое поле памяти, которое называется **дескриптором** сегмента. Структура дескриптора представлена на рисунке 1.

![[Pasted image 20240107004331.png]]

Рисунок 1 — Структура дескриптора сегмента

Адрес сегмента занимает участки $A_1$ и $A_2$ дескриптора. Их суммарная длина равна 32 разрядам, что соответствует адресному пространству объёмом 4 Гбайт.
Значение длины сегмента занимает участки $L_1$ и $L_2$ дескриптора, суммарная длина которых равна 20 бит. Длина сегмента может измеряться в байтах или страницах, длина последних всегда равна 4 Кбайт.
Выбор единицы измерения длины сегмента зависит от значения бита **гранулярности G**. При значении $G = 0$ длина сегмента измеряется в байтах, при этом 20-битовое поле длиной $L (L_1 + L_2)$ обеспечивает возможность задания длины сегмента в пределах от 1 байта до $2^{20}$ байт = 1 Мбайт. При значении G = 1 длина сегмента измеряется в страницах. В этом случае она может изменяться в пределах от одной страницы (4 Кбайт) до 220 страниц ($2^{20}$ * 4 Кбайт — 4 Гбайт).
В связи с необходимостью поддерживать совместимость с предшествующими 16-битовыми моделями в дескрипторе сегмента предусмотрен **бит разрядности D**, значение которого определяет используемую в сегменте разрядность операндов и адресов. Если значение D = 0, то используется 16-битовая, а при D = 1 — 32-битовая разрядность адресов и операндов.
В отличие от реального режима, в защищенном режиме возможны только два принципиально разных типа сегментов: сегмент кода и сегмент данных. Тип сегмента определяется значением **бита назначения сегмента I**. Если значение I = 0, то дескриптор описывает сегмент данных; если же I = 1, то это сегмент кода.
Сегмент стека считается самостоятельной разновидностью сегмента данных с особым способом изменения его длины. Стек растет в направлении уменьшения адресов оперативной памяти, в то время как у обычной разновидности сегмента данных рост происходит в направлении увеличения адресов памяти. В связи с этим разновидность сегмента данных уточняется с помощью **бита направления расширения ED** (от Expand Down — расширение вниз). Если значение ED = 0, то сегмент расширяется вниз, то есть в направлении увеличения адресов памяти (обычный сегмент данных). В противном случае, при ED = 1, сегмент растет в направлении убывания адресов памяти (стек). 
Любая выполняемая задача может создать и запустить на выполнение некоторую подчиненную задачу. В связи с этим различают обычные и подчиненные сегменты кода. Обычный сегмент кода содержит программу порождающей задачи, а подчиненный сегмент кода — программу порожденной, подчиненной задачи. Разновидность сегмента кода определяется значением **подчиненного бита С** (от Conforming — подчиненный). Если значение С = 0, то сегмент кода считается подчиненным, а при С = 1 сегмент считается обычным. На самом деле биты ED и С — это не два разных бита в дескрипторе, а один и тот же бит, который принято обозначать C/ED и трактовать его смысл и значение в зависимости от значения бита I.
Программа, занимающая сегмент кода, всегда может быть выполнена. Запись в сегмент кода запрещена, а возможность чтения программного кода из этого сегмента, например с целью его копирования, регулируется битом чтения/записи R/W. Значение R/W = 0 запрещает чтение, а R/W = 1 — разрешает.
Чтение из сегмента данных разрешено всегда. Возможность записи в этот сегмент регулируется этим же битом R/W. Значение R/W = 0 запрещает запись, а значение R/W = 1 разрешает ее.
Таким образом, тройка битов 1, C/ED и R/W определяет тип сегмента и допустимые операции с его содержимым. Все возможные комбинации этих битов

Таблица 1. Типы сегментов памяти в защищённом режиме.

| I | C/ED | R/W | Код типа | Назначение сегмента |
| ---- | ---- | ---- | ---- | ---- |
| 0 | 0 | 0 | 000 | Сегмент данных, запись запрещена |
| 0 | 0 | 1 | 001 | Сегмент данных, запись разрешена |
| 0 | 1 | 0 | 010 | Не определено |
| 0 | 1 | 1 | 011 | Сегмент стека, запись разрешена |
| 1 | 0 | 0 | 100 | Подчинённый сегмент кода, чтение запрещено |
| 1 | 0 | 1 | 101 | Подчинённый сегмент кода, чтение разрешено |
| 1 | 1 | 0 | 110 | Обычный сегмент кода, чтение запрещено |
| 1 | 1 | 1 | 111 | Обычный сегмент кода, чтение разрешено |
Код типа сегмента I, C/ED, R/W является составной частью байта **прав доступа AR** (от Access Right), входящего в дескриптор сегмента. В этот байт также входят **бит присутствия Р** (от Present), **код уровня привилегий дескриптора DPL** (от Descriptor Privilege Level), **бит система/сегмент S** (от System/Segment) и **бит доступа А** (от Accessed).
Бит присутствия Р аппаратно получает значение 0, если в текущий момент времени сегмент отсутствует в оперативной памяти, и значение 1, если сегмент находится в ней. Бит доступа А также аппаратно получает значение 1 при обращении к сегменту (для чтения или записи), в противном случае его значение устанавливается в 0. Эти два бита используются механизмами виртуальной памяти.
Для определения роли дескриптора служит бит система/сегмент S, который принимает значение 0, если дескриптор служит для описания системного объекта, и значение 1, если дескриптор используется для описания сегмента памяти.
Наивысший приоритет имеют сегменты нулевого уровня, у которых код DPL равен $00_2$, а минимальный уровень имеют сегменты с кодом DPL, равным $11_2$.
Кроме рассмотренных полей и битов в дескрипторе имеется не используемый бит О и используемый программистом по своему усмотрению бит пользователя U (от User).
# Линейный адрес
В защищенном режиме в оперативной памяти выделяются **глобальные** сегменты памяти, к которым имеют доступ все выполняющиеся программы. Кроме того, каждой из выполняющихся программ выделяются индивидуальные **локальные** сегменты памяти, к которым имеет доступ только программа-владелец этих сегментов и никакие другие программы доступа не имеют.
Дескрипторы сегментов памяти в зависимости от их назначения группируются в различные **дескрипторные таблицы**. Дескрипторы глобальных сегментов находятся в глобальной дескрипторной таблице **GDT** (от Global Descriptor Тablе), а дескрипторы локальных сегментов находятся в локальных дескрипторных таблицах **LDT** (от Local Descriptor Таblе) программы. Подчеркнем, что глобальная таблица GDT всего одна, а локальных таблиц много, точнее, столько, сколько одновременно выполняется задач. Элементы таблиц (дескрипторы) выделяются с помощью их номеров — индексов, которые входят в так называемые **селекторы** (от select — выделять).
Для определения местоположения таблиц GDT и LDT, а также некоторых других системных объектов применяются два различных способа, в которых используется содержимое регистров системных адресов процессора с длиной 6 и 2 байта.
Регистры системных адресов длиной 6 байт содержат 32-битовый адрес и 16-битовую длину таблиц или объектов, имеющих значение для всей системы. Адрес таблицы глобальных дескрипторов находится в системном регистре с названием **GDTR** (от Global Descriptor Тablе Register). Обращение по адресу, указанному в этом регистре, сразу приведет к начальному элементу дескрипторной таблицы.
Регистры системных адресов длиной 2 байта содержат селектор дескриптора сегмента памяти, в котором находится указываемый объект. С помощью селектора вначале нужно выбрать из таблицы GDT дескриптор соответствующего сегмента памяти, а потом из дескриптора выбрать адрес сегмента, в котором находится нужная таблица. Селектор дескриптора сегмента памяти, который содержит локальную дескрипторную таблицу, находится в системном регистре **LDTR** (от Local Descriptor Таblе Register).
Чтобы в защищенном режиме определить адрес какого-либо сегмента памяти, во-первых, необходимо знать, является этот сегмент глобальным или локальным, а во-вторых, нужен селектор дескриптора, выделяющий его из соответствующей таблицы. Эта информация находится в одном из сегментных регистров процессора, которые в защищенном режиме содержат не начальные адреса сегментов, а селекторы дескрипторов. С их помощью из соответствующей таблицы GDT или LDT выбираются дескрипторы сегментов, содержащие не только начальный адрес, но и все остальные атрибуты сегмента.
Для определения адреса поля памяти в защищенном режиме, так же как и в реальном, нужно знать адрес сегмента и внутрисегментное смещение. Способ определения внутрисегментного смещения — эффективного адреса не отличается от используемого в реальном режиме. Для сегментов кода он выбирается из регистра **EIP**, а для сегментов данных и стека формируется из содержимого индексных регистров **ESI** и **EDI**, базовых регистров **EBX**, **EBP** и смещения, заданного в команде `Dk`.
После определения 32-битового адреса сегмента он складывается с 32-битовым эффективным адресом. Полученный таким образом адрес называется **линейным**(адрес в виртуальной памяти). Если механизмы виртуальной памяти отключены, то линейный адрес является одновременно *физическим*, или *исполнительным*, адресом, который выставляется на адресную шину и по которому происходит фактическое обращение в оперативную память.